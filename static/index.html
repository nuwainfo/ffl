<!DOCTYPE html>
<!--
FastFileLink CLI at https://github.com/nuwainfo/ffl
Licensed under Apache-2.0 license.
-->
<html lang="en">
<head>
    <!--Workaround for fixing Django CMS issues-->
    <meta name="comment" content="The template was modified by Nuwainfo.com"/>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
    <meta name="description" content="None"/>
    <meta name="author" content=""/>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""/>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;500;700;900&amp;display=swap"
          rel="stylesheet"/>
    <title>FastFileLink</title>
    <!-- Bootstrap core CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    <!-- Additional CSS Files -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous"/>

    <!-- Custom CSS Files -->
    <link rel="stylesheet" href="{{ STATIC_SERVER }}/static/client/theme.css">

    <!-- To avoid favicon.ico not found error -->
    <link rel="icon" href="{{ STATIC_SERVER }}/static/client/Logo.png" type="image/x-icon">
        
    <!-- InApp Browser Detection Warning Styles -->
    <link rel="stylesheet" href="{{ STATIC_SERVER }}/static/css/InAppGuard.css">
    
    <!-- DownloadManager Styles -->
    <link rel="stylesheet" href="{{ STATIC_SERVER }}/static/css/DownloadUI.css">

    <!-- E2EE (End-to-End Encryption) UI Styles -->
    <link rel="stylesheet" href="{{ STATIC_SERVER }}/static/css/E2EE.css">

    <!-- i18next internationalization scripts -->
    <script src="https://unpkg.com/i18next@25.5.2/dist/umd/i18next.js"></script>
    <script src="https://unpkg.com/i18next-http-backend@3.0.2/i18nextHttpBackend.js"></script>
    <script src="https://unpkg.com/i18next-browser-languagedetector@8.2.0/dist/umd/i18nextBrowserLanguageDetector.min.js"></script>
    <script src="https://unpkg.com/jquery-i18next@1.2.1/dist/umd/jquery-i18next.min.js"></script>
    <script src="{{ STATIC_SERVER }}/static/js/FFLI18n.js"></script>
</head>
    <body>
        <div id="pricing" class="main-banner wow fadeIn pricing-tables">
            <div class="container">
                <div class="right-image wow fadeInRight row">
                    <div class="col-lg-8 offset-lg-2">
                        <div class="section-heading">
                            <h4>
                                <span data-i18n="download.title">Downloading</span>
                                <em><span data-i18n="download.file">File</span></em>
                                <i id="file-info-icon" class="fas fa-info-circle" 
                                   style="margin-left: 8px; margin-right: 8px; color: #007bff; cursor: help; font-size: 0.8em;"
                                   title="" 
                                   data-bs-toggle="tooltip" 
                                   data-bs-placement="bottom"></i>
                                <span data-i18n="download.ellipsis">...</span>
                            </h4>
                        </div>
                    </div>
                    <div class="col-lg-4 offset-lg-4">
                        <!-- InApp Browser Warning -->
                        <div id="inapp-warning" class="inapp-warning">
                            <i class="fas fa-exclamation-triangle warning-icon"></i>
                            <div class="warning-title" data-i18n="download.warning.title">Download may not work in this browser</div>
                            <div id="warning-text" class="warning-text" data-i18n="download.warning.text">
                                To download this file, please open this link in your browser.
                            </div>
                            <a id="open-browser-btn" href="#" class="open-browser-btn">
                                <i class="fas fa-download"></i> <span data-i18n="download.warning.button">Download in Browser</span>
                            </a>
                        </div>
                        
                        <div class="pricing-item-pro" style="background-color: rgba(255, 255, 255, 0.5);">
                            <!-- Status Display -->
                            <div id="statusText" style="text-align: center; font-weight: bold; margin-bottom: 15px;" data-i18n="client.status.establishing">Establishing connection...</div>
                            
                            <!-- Progress Bar -->
                            <div class="progress" style="margin-bottom: 20px;">
                                <progress id="downloadProgress" value="0" max="100" style="width: 100%;"></progress>
                            </div>
                            
                            <!-- Connection Type Display -->
                            <div id="connectionType" style="text-align: center; color: #007bff; font-size: 14px; margin-bottom: 10px;"></div>

                            <div class="border-button">
                                <h6 id="download-message" data-i18n="client.download.startShortly">Your download will start shortly.</h6>
                                <div id="status-details" style="font-size: 14px; color: #666; margin-top: 5px;"></div>
                            </div>
                                                        
                            <!-- Retry functionality (hidden by default) -->
                            <div class="delayed-show" style="display: none;">
                                <a id="retry-link" href="#" class="btn btn-primary" data-i18n="client.retry.button">Retry Download</a>
                                <div id="retry-confirmation" class="retry-confirmation" style="display: none;">
                                    <div class="retry-confirmation-title" data-i18n="client.retry.confirmationTitle">Open download in new tab?</div>
                                    <a id="confirm-retry" href="#" target="_blank" class="confirm-retry-btn" data-i18n="download.retry.confirmButton">Yes, Open New Tab</a>
                                    <button id="cancel-retry" class="cancel-retry-btn" data-i18n="download.retry.cancelButton">Cancel</button>
                                </div>
                            </div>

                            <!-- E2EE Retry Blocked Warning -->
                            <div id="e2ee-retry-blocked" class="e2ee-retry-blocked">
                                <div class="e2ee-retry-blocked-icon">ðŸ”’</div>
                                <div class="e2ee-retry-blocked-title" data-i18n="download.e2ee.retryBlocked.title">
                                    Encrypted Download Requires This Page
                                </div>
                                <div class="e2ee-retry-blocked-message" data-i18n="download.e2ee.retryBlocked.message">
                                    Direct browser downloads cannot decrypt this file. The decryption must happen in this page with your encryption key.
                                </div>
                                <div class="e2ee-retry-blocked-solutions">
                                    <div class="e2ee-retry-blocked-subtitle" data-i18n="download.e2ee.retryBlocked.solutionsTitle">
                                        Try these solutions:
                                    </div>
                                    <ul class="e2ee-retry-blocked-list">
                                        <li data-i18n="[html]download.e2ee.retryBlocked.solution1">
                                            <strong>Different Browser:</strong> Try Chrome, Edge, or Brave for better compatibility
                                        </li>
                                        <li>
                                            <strong data-i18n="download.e2ee.retryBlocked.solution2Title">Command Line Tool:</strong>
                                            <span data-i18n="download.e2ee.retryBlocked.solution2Text">Use the</span>
                                            <a href="https://github.com/nuwainfo/ffl" target="_blank" rel="noopener" class="e2ee-cli-link">FastFileLink CLI</a>
                                            <span data-i18n="download.e2ee.retryBlocked.solution2Stable">for stable downloads of large encrypted files</span>
                                        </li>
                                        <li data-i18n="[html]download.e2ee.retryBlocked.solution3">
                                            <strong>Wait:</strong> The download may still be progressing in the background
                                        </li>
                                    </ul>
                                </div>
                            </div>

                            <!-- Close tab option (shown after opening new tab) -->
                            <div id="close-tab-wrap" class="close-tab-wrap" style="display: none; text-align: center; margin-top: 10px;">
                                <a id="close-this-tab" href="#" class="btn btn-secondary" style="padding: 8px 16px; border-radius: 20px;" data-i18n="download.closeTab">Close this tab</a>
                            </div>                          
                              
                            <!-- Fallback Download Button - Hidden -->                            
                            <div id="fallback-container" style="display: none;">
                                <!-- Visible button for manual user clicks - remains functional -->
                                <div class="border-button">
                                    <a id="manual-download-link" href="/uid=****/download" data-i18n="client.manualDownload">Download</a>
                                </div>                               
                            </div>

                            <!-- Hidden file metadata -->
                            <p id="fileName" style="display:none;">{{ fileName }}</p>
                            <p id="fileSize" style="display:none;">{{ fileSize }}</p>
                            
                            <!-- Always visible footer message -->
                            <div class="border-button">
                                <p style="font-size: 14px; margin-top: 10px; line-height: 1.2;">
                                    {{ FOOTER_MESSAGE_HTML }}
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- No-JavaScript Fallback -->
        <noscript>
            <style>
                #fallback-container {
                    display: block !important;
                }
            </style>
        </noscript>
        <footer id="newsletter">
            <div class="container">
                <div class="row">
                    <div class="col-lg-12">
                        <div class="copyright-text">
                            <p>
                                <span>{{ COPYRIGHT }}</span>
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </footer>
        <!-- Scripts -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
                integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
                crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js" 
                integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" 
                crossorigin="anonymous"></script>
        <!--<script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.6/StreamSaver.min.js"></script>-->
        <!-- Support blob for debugging -->
        <script src="{{ STATIC_SERVER }}/static/js/StreamSaver.js?blob={{ STREAMSAVER_BLOB }}"></script>

        <!-- Shared Logging -->
        <script>
            // Debug configuration and logging setup (must be first)
            const DEBUG = false; // Set to true to enable detailed logging
            const SERVER_DEBUG = false; // Server-injected: enables mobile debugging via JS_LOG_TO_SERVER_DEBUG + ?debug=server

            // Generate unique session ID for this client session (for multi-user debug logging)
            const generateSessionId = () => {
                if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                    return crypto.randomUUID();
                } else {
                    // Fallback for older browsers
                    return 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                }
            };
            const DEBUG_SESSION_ID = SERVER_DEBUG ? generateSessionId() : null;

            // Function to send logs to server for mobile debugging
            const sendLogToServer = (category, message, timestamp) => {
                try {
                    fetch('/debug/log', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            category: category,
                            message: message,
                            timestamp: timestamp,
                            sessionId: DEBUG_SESSION_ID
                        })
                    }).catch(err => {
                        // Silently ignore server logging errors to avoid infinite loops
                        if (DEBUG) console.warn('Failed to send log to server:', err);
                    });
                } catch (err) {
                    // Silently ignore errors
                    if (DEBUG) console.warn('Error in sendLogToServer:', err);
                }
            };

            // Global logger function (available to all scripts)
            const log = (category, message, ...args) => {
                // First determine whether to output to console/server (preserve original switch semantics)
                let printToConsole = !!DEBUG;
                let sendToServer = !!SERVER_DEBUG;

                // Check if the last parameter is an "options" object
                if (args.length > 0) {
                    const last = args[args.length - 1];

                    if (typeof last === 'boolean') {
                        // Last param is boolean: controls whether to send to server
                        sendToServer = sendToServer && last;   // false => disable sending; true => maintain original gating
                        args.pop(); // Remove flag from args to avoid it being included in the message
                    } else if (
                        last &&
                        typeof last === 'object' &&
                        !Array.isArray(last) &&
                        (Object.prototype.hasOwnProperty.call(last, 'server') ||
                         Object.prototype.hasOwnProperty.call(last, 'console'))
                    ) {
                        // Last param is options object: { server?: boolean, console?: boolean }
                        if ('server' in last)  sendToServer   = sendToServer   && !!last.server;
                        if ('console' in last) printToConsole = printToConsole && !!last.console;
                        args.pop(); // Remove options object from args
                    }
                }

                // Early return if nothing should be logged
                if (!printToConsole && !sendToServer) {
                    return;
                }
                
                const timestamp = new Date().toISOString(); 
                const prefix = `[${timestamp}] [${category}]`;
                const fullMessage = args.length > 0 ? `${message} ${JSON.stringify(args)}` : message;

                // Output to console if enabled
                if (printToConsole) {
                    if (args.length > 0) {
                        console.log(`${prefix} ${message}`, ...args);
                    } else {
                        console.log(`${prefix} ${message}`);
                    }
                }

                // Send to server if enabled
                if (sendToServer) {
                    sendLogToServer(category, fullMessage, timestamp);
                }
            };
        </script>
        
        <!-- Initialize i18n using common initialization -->
        <script>
            // Initialize i18n system with log function
            initializeI18n({
                log: log,
                localesPath: '{{ STATIC_SERVER }}/static/locales'
            });
        </script>
                
        <!-- Include InApp Guard -->
        <script src="{{ STATIC_SERVER }}/static/js/InAppGuard.js"></script>
        <script>
            // Initialize file info tooltip with filename and file size
            function initializeFileInfoTooltip() {
                // Get filename and file size from hidden metadata
                const fileName = document.getElementById('fileName')?.textContent || 'download.bin';
                const fileSizeElement = document.getElementById('fileSize');
                let fileSize = 0;
                
                if (fileSizeElement) {
                    const sizeText = fileSizeElement.textContent || fileSizeElement.innerText || '0';
                    fileSize = parseInt(sizeText.trim(), 10);
                    if (isNaN(fileSize)) fileSize = 0;
                }
                
                // Format file size
                function formatBytes(bytes) {
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
                }
                
                const formattedSize = formatBytes(fileSize);
                
                // Create tooltip content with translations
                const tooltipContent = `${fileName}\n${formattedSize}`;
                
                // Set tooltip title and initialize Bootstrap tooltip
                const tooltipElement = document.getElementById('file-info-icon');
                if (tooltipElement) {
                    tooltipElement.setAttribute('title', tooltipContent);
                    
                    // Initialize Bootstrap tooltip if available
                    if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {
                        new bootstrap.Tooltip(tooltipElement, {
                            placement: 'bottom',
                            title: tooltipContent
                        });
                    }
                }
                
                log('FileInfoTooltip', `Initialized tooltip: ${fileName} (${formattedSize})`);
            }
            
            // Initialize file info tooltip
            initializeFileInfoTooltip();
           
           // Global variable to track if we should skip WebRTC
            let SKIP_WEBRTC_DUE_TO_RESTRICTION = false;

            // Initialize InApp Guard using centralized function
            SKIP_WEBRTC_DUE_TO_RESTRICTION = InAppGuard.initInAppGuardUI({
                log: log,
                skipVariableName: 'SKIP_WEBRTC_DUE_TO_RESTRICTION'
            });            
        </script>
        
        <!-- DownloadManager integration -->
        <script src="{{ STATIC_SERVER }}/static/js/DownloadManager.js"></script>

        <!-- E2E Encryption Support -->
        <script src="{{ STATIC_SERVER }}/static/js/E2EE.js"></script>

        <script>
            /**
             * WritePump: Write queue manager with single state machine
             * Manages writer (StreamSaver or BlobWriter) with guaranteed write ordering and proper completion.
             */
            class WritePump {

                constructor(writer, expectedSize = null, callbacks = {}) {
                    this.writer = writer;
                    this.expected = Number.isFinite(expectedSize) ? expectedSize : null;
                    this.bytesWritten = 0;

                    this.onComplete = callbacks.onComplete || (() => {});
                    this.onFallback = callbacks.onFallback || ((reason) => this.log('WritePump', `Fallback: ${reason}`));
                    this.log = callbacks.log || ((tag, msg) => console.log(`[${tag}] ${msg}`));

                    // Single-threaded queue - no concurrent writes
                    this.queue = [];
                    this.intakeOpen = true;     // Accept new chunks?
                    this.draining = false;      // Drain loop running?
                    this.inFlight = 0;          // Number of writes in progress (should always be 0 or 1)
                    this.drainLoopPromise = null;
                    this.idleResolver = null;   // Resolves when queue empty and inFlight=0
                    this.writeError = null;     // First error encountered
                }

                isAccepting() {
                    return this.intakeOpen && !this.writeError;
                }

                enqueue(chunk) {
                    if (!this.intakeOpen) {
                        // After EOF, ignore new chunks (prevents race condition)
                        return false;
                    }

                    if (this.writeError) {
                        this.log('WritePump', `Skipping write due to previous error: ${this.writeError}`);
                        return false;
                    }

                    this.queue.push(chunk);

                    // Start drain loop if not already running
                    if (!this.drainLoopPromise) {
                        this.drainLoopPromise = this._drainLoop();
                    }

                    return true;
                }

                async eof() {
                    if (!this.intakeOpen) {
                        this.log('WritePump', 'EOF called but intake already closed, ignoring');
                        return;
                    }

                    // Close intake immediately - no more chunks accepted
                    this.intakeOpen = false;
                    this.log('WritePump', `EOF received, queue=${this.queue.length}, inFlight=${this.inFlight}, bytesWritten=${this.bytesWritten}`);

                    try {
                        // Wait for queue to drain completely (no timeout, no race)
                        await this._waitIdle();
                        this.log('WritePump', `Queue drained, bytesWritten=${this.bytesWritten}`);

                        // Close writer only after all writes complete
                        await this.writer.close();
                        this.log('WritePump', 'Writer closed successfully');

                        // Verify size matches expectation
                        if (this.expected !== null && this.bytesWritten !== this.expected) {
                            const reason = `Size mismatch: written=${this.bytesWritten}, expected=${this.expected}`;
                            this.log('WritePump', reason);
                            this.onFallback(reason);
                            return;
                        }

                        // Success! Pass writer reference for blob downloads
                        this.onComplete({
                            bytesWritten: this.bytesWritten,
                            writer: this.writer
                        });

                    } catch (err) {
                        this.log('WritePump', `EOF error: ${err?.message || err}`);
                        this.onFallback(`Writer error: ${err?.message || err}`);
                    }
                }

                async prepareForFallback(timeoutMs, reason = 'fallback') {
                    if (!this.intakeOpen) {
                        this.log('WritePump', 'Prepare for fallback called but intake already closed');
                        return;
                    }

                    // Stop accepting new writes immediately
                    this.intakeOpen = false;
                    this.log('WritePump', `Preparing for fallback with ${timeoutMs}ms deadline: ${reason}`);
                    this.log('WritePump', `Current state: queue=${this.queue.length}, inFlight=${this.inFlight}, bytesWritten=${this.bytesWritten}`);

                    const deadline = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('deadline')), timeoutMs)
                    );

                    try {
                        // Try to wait for queue to drain within timeout
                        await Promise.race([this._waitIdle(), deadline]);
                        this.log('WritePump', `All writes flushed within deadline, bytesWritten=${this.bytesWritten}`);
                    } catch (err) {
                        this.log('WritePump', `Deadline exceeded, some writes may be lost: ${err?.message || err}`);
                        this.log('WritePump', `Final state: queue=${this.queue.length}, inFlight=${this.inFlight}, bytesWritten=${this.bytesWritten}`);
                    }

                    // DO NOT close writer - let DownloadManager reuse it for HTTP resume
                    this.log('WritePump', `Ready for fallback, writer still open for DownloadManager`);
                    this.onFallback(reason);
                }

                async _drainLoop() {
                    if (this.draining) {
                        this.log('WritePump', 'Drain loop already running');
                        return;
                    }

                    this.draining = true;

                    try {
                        while (this.queue.length > 0) {
                            const chunk = this.queue.shift();
                            this.inFlight++;

                            try {
                                // Write one chunk at a time - fully await before next
                                await this.writer.write(chunk);
                                this.bytesWritten += chunk.byteLength || chunk.size || chunk.length || 0;
                            } catch (err) {
                                // Store first error and stop processing
                                if (!this.writeError) {
                                    this.writeError = err.message || String(err);
                                    this.log('WritePump', `Write error: ${this.writeError}`);
                                }
                                throw err;
                            } finally {
                                this.inFlight--;
                            }
                        }
                    } finally {
                        this.draining = false;
                        this.drainLoopPromise = null;

                        // If idle and someone is waiting, resolve them
                        if (this.queue.length === 0 && this.inFlight === 0 && this.idleResolver) {
                            const resolve = this.idleResolver;
                            this.idleResolver = null;
                            resolve();
                        }
                    }
                }

                async _waitIdle() {
                    // Already idle?
                    if (this.queue.length === 0 && this.inFlight === 0) {
                        return;
                    }

                    // Wait for drain loop to finish
                    return new Promise((resolve) => {
                        this.idleResolver = resolve;
                    });
                }
            }

        /**
         * BlobWriter: Writer implementation that accumulates chunks in memory
         * Mimics WritableStream writer interface for compatibility with WritePump
         * Automatically triggers download when closed
         */
        class BlobWriter {
            constructor(fileName, expectedSize = null) {
                this.fileName = fileName;
                this.chunks = [];
                this.bytesWritten = 0;
                this.expectedSize = expectedSize;
                this.closed = false;
            }

            async write(chunk) {
                if (this.closed) {
                    throw new Error('Writer is closed');
                }

                // Store a copy to prevent external modifications
                const chunkView = chunk instanceof ArrayBuffer
                    ? new Uint8Array(chunk.slice(0))
                    : new Uint8Array(chunk);

                this.chunks.push(chunkView);
                this.bytesWritten += chunkView.byteLength;
            }

            async close() {
                if (this.closed) {
                    return;
                }
                this.closed = true;

                // Size verification
                if (this.expectedSize !== null && this.bytesWritten !== this.expectedSize) {
                    throw new Error(`Size mismatch: written=${this.bytesWritten}, expected=${this.expectedSize}`);
                }

                // Automatically trigger blob download on close
                this.triggerDownload();
            }

            triggerDownload() {
                if (!this.closed) {
                    throw new Error('Writer must be closed before triggering download');
                }

                log("BlobWriter", `Creating blob download for ${this.fileName} (${this.bytesWritten} bytes)`);

                const blob = new Blob(this.chunks, { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = this.fileName;
                a.style.display = 'none';
                document.body.appendChild(a);

                log("BlobWriter", `Triggering download for ${this.fileName}`);
                a.click();

                setTimeout(() => {
                    log("BlobWriter", "Cleaning up object URL");
                    URL.revokeObjectURL(url);
                    a.remove();
                }, 60000);
            }
        }

        /**
         * WriterFactory: Creates appropriate writer based on file size and browser capabilities
         */
        class WriterFactory {
        
            static create(fileName, fileSize) {
                const USE_BLOB_THRESHOLD = 10 * 1024 * 1024; // 10MB

                // Check if StreamSaver is available and needed
                const canUseSW = location.protocol === 'https:' ||
                                location.hostname === 'localhost' ||
                                location.hostname === '127.0.0.1';

                const streamSaverReady = canUseSW &&
                                        'serviceWorker' in navigator &&
                                        typeof streamSaver !== 'undefined';

                // Use StreamSaver for large files if available
                if (streamSaverReady && fileSize > USE_BLOB_THRESHOLD) {
                    try {
                        log("WriterFactory", `Creating StreamSaver writer for ${fileName} (${fileSize} bytes)`);

                        // Configure StreamSaver (encapsulated here)
                        if (!streamSaver.mitm) {
                            streamSaver.mitm = '/static/assets/mitm.html';
                        }

                        const fileStream = streamSaver.createWriteStream(fileName, {
                            size: fileSize || undefined
                        });

                        const writer = fileStream.getWriter();

                        return {
                            type: 'streamsaver',
                            writer: writer,
                            fileName: fileName,
                            fileSize: fileSize
                        };
                    } catch (e) {
                        log('WriterFactory', 'StreamSaver initialization failed, falling back to Blob', e);
                        // Fall through to blob creation
                    }
                }

                // Use Blob for small files or when StreamSaver not available
                log("WriterFactory", `Creating Blob writer for ${fileName} (${fileSize} bytes)`);
                const blobWriter = new BlobWriter(fileName, fileSize);

                return {
                    type: 'blob',
                    writer: blobWriter,
                    fileName: fileName,
                    fileSize: fileSize
                };
            }

            static getUnsupportedReason(fileSize) {
                const USE_BLOB_THRESHOLD = 10 * 1024 * 1024;

                if (fileSize <= USE_BLOB_THRESHOLD) {
                    return null; // Small files always supported
                }

                const canUseSW = location.protocol === 'https:' ||
                                location.hostname === 'localhost' ||
                                location.hostname === '127.0.0.1';

                if (!canUseSW) {
                    return 'ServiceWorker not available (requires HTTPS or localhost)';
                }

                if (!('serviceWorker' in navigator)) {
                    return 'ServiceWorker not supported by browser';
                }

                if (typeof streamSaver === 'undefined') {
                    return 'StreamSaver library not loaded';
                }

                return null;
            }

            static isSupported(fileSize) {
                return this.getUnsupportedReason(fileSize) === null;
            }
        }
        </script>

        <!-- Utility Functions -->
        <script>
            // Helper function to parse boolean-like parameters (matches server-side parseURLBooleanParam)
            const parseBooleanParam = (value, defaultValue = false) => {
                if (!value)
                    return defaultValue;

                const lowerValue = value.toLowerCase();

                // True values: true, 1, on, yes (case-insensitive)
                if (['true', '1', 'on', 'yes'].includes(lowerValue)) {
                    return true;
                }

                // False values: false, 0, off, no (case-insensitive)
                if (['false', '0', 'off', 'no'].includes(lowerValue)) {
                    return false;
                }

                // Unrecognized value - return default
                return defaultValue;
            };

            // Helper function to check if an IP is a local/private IP
            const isLocalIp = (ip) => {
                if (typeof ip !== 'string')
                    return false;

                const s = ip.toLowerCase().trim();
                return (
                    // IPv6 loopback
                    s === '::1' ||
                    // mDNS / hostname
                    s.endsWith('.local') ||
                    // IPv4 loopback
                    s.startsWith('127.') ||
                    // Private IPv4
                    s.startsWith('10.') ||
                    s.startsWith('192.168.') ||
                    /^172\.(1[6-9]|2[0-9]|3[0-1])\./.test(s) || // 172.16.0.0 ~ 172.31.255.255
                    // IPv4 link-local
                    s.startsWith('169.254.') ||
                    // IPv6 link-local / ULA
                    s.startsWith('fe80:') || // link-local
                    s.startsWith('fc')   ||  // fc00::/7
                    s.startsWith('fd')       // fd00::/8
                );
            };

            // Browser detection utility
            const getBrowserInfo = () => {
                const ua = navigator.userAgent;
                const vendor = navigator.vendor || '';

                // Check Edge first (before Chrome, since Edge contains "Chrome" in UA)
                if (ua.includes('Edg/') || ua.includes('Edge/')) {
                    return 'edge';
                } else if (ua.includes('Chrome') && vendor.includes('Google')) {
                    return 'chrome';
                } else if (ua.includes('Firefox')) {
                    return 'firefox';
                } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
                    return 'safari';
                }
                return 'unknown';
            };

            // Detect RTC connection type (local vs remote)
            const detectRTCConnectionType = async () => {
                // Check if RTCPeerConnection is supported
                if (typeof RTCPeerConnection === 'undefined') {
                    log("Connection", "RTCPeerConnection not supported, skipping connection type detection");
                    return { isLocalConnection: false, detectedIp: null };
                }

                return new Promise((resolve, reject) => {
                    const tempPc = new RTCPeerConnection({
                        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                    });

                    const timeout = setTimeout(() => {
                        tempPc.close();
                        resolve({ isLocalConnection: false, detectedIp: null });
                    }, 5000);

                    let hostIps = new Set();
                    let srflxIps = new Set();
                    let hasLocalCandidate = false;
                    let candidateCount = 0;

                    tempPc.onicecandidate = (event) => {
                        if (event.candidate) {
                            const candidate = event.candidate.candidate;
                            candidateCount++;
                            log("ICE-Detect", `Candidate ${candidateCount}: ${candidate.substring(0, 80)}...`);

                            // Parse candidate string
                            const parts = candidate.split(' ');
                            let ip = null;
                            let candidateType = null;

                            // Find type first
                            for (let i = 0; i < parts.length; i++) {
                                if (parts[i] === 'typ' && i + 1 < parts.length) {
                                    candidateType = parts[i + 1];
                                    break;
                                }
                            }

                            // Find IP based on candidate type and format
                            if (candidateType === 'host') {
                                // For host candidates, IP could be at index 4 or could be .local format
                                for (let i = 0; i < parts.length; i++) {
                                    const part = parts[i];
                                    // Check for IPv4 address
                                    if (/^\d+\.\d+\.\d+\.\d+$/.test(part)) {
                                        ip = part;
                                        break;
                                    }
                                    // Check for .local mDNS format (indicates local network)
                                    else if (part.endsWith('.local')) {
                                        ip = part;
                                        hasLocalCandidate = true;
                                        break;
                                    }
                                    // Check for IPv6 link-local or ULA
                                    else if (part.startsWith('fe80:') || part.startsWith('fc') || part.startsWith('fd')) {
                                        ip = part;
                                        hasLocalCandidate = true;
                                        break;
                                    }
                                }
                            } else if (candidateType === 'srflx') {
                                // For srflx candidates, IP is usually at index 4
                                if (parts[4] && /^\d+\.\d+\.\d+\.\d+$/.test(parts[4])) {
                                    ip = parts[4];
                                }
                            }

                            if (ip && candidateType) {
                                log("ICE-Detect", `Parsed - IP: ${ip}, Type: ${candidateType}`);

                                if (candidateType === 'host') {
                                    hostIps.add(ip);

                                    // Check if this is a local IP
                                    if (isLocalIp(ip)) {
                                        hasLocalCandidate = true;
                                    }
                                } else if (candidateType === 'srflx') {
                                    srflxIps.add(ip);
                                }

                                // Check if we have enough information
                                if (candidateCount >= 2) {
                                    clearTimeout(timeout);
                                    tempPc.close();

                                    const hostIpArray = Array.from(hostIps);
                                    const srflxIpArray = Array.from(srflxIps);

                                    // Determine if this is a local connection
                                    // If we have .local candidates or private IPs, it's local
                                    const isLocalConnection = hasLocalCandidate || hostIpArray.some(isLocalIp);

                                    const result = {
                                        isLocalConnection: isLocalConnection,
                                        detectedIp: `host:[${hostIpArray.join(',')}] srflx:[${srflxIpArray.join(',')}]`
                                    };

                                    log("Connection", `Detection result - Local: ${result.isLocalConnection}, IPs: ${result.detectedIp}`);
                                    resolve(result);
                                    return;
                                }
                            }
                        } else {
                            // End of candidates
                            clearTimeout(timeout);
                            tempPc.close();

                            const hostIpArray = Array.from(hostIps);
                            const srflxIpArray = Array.from(srflxIps);

                            const isLocalConnection = hasLocalCandidate || hostIpArray.some(isLocalIp);

                            const result = {
                                isLocalConnection: isLocalConnection,
                                detectedIp: `host:[${hostIpArray.join(',')}] srflx:[${srflxIpArray.join(',')}]`
                            };

                            log("Connection", `Final detection - Local: ${result.isLocalConnection}, IPs: ${result.detectedIp}`);
                            resolve(result);
                        }
                    };

                    tempPc.onicegatheringstatechange = () => {
                        log("ICE-Detect", `ICE gathering state: ${tempPc.iceGatheringState}`);
                    };

                    // Create data channel to trigger ICE gathering
                    tempPc.createDataChannel('detect');

                    tempPc.createOffer()
                        .then(offer => tempPc.setLocalDescription(offer))
                        .catch(reject);
                });
            };

            // Get comprehensive connection information
            const getConnectionInfo = async () => {
                const baseInfo = {
                    browser: getBrowserInfo(),
                    domain: window.location.hostname,
                    protocol: window.location.protocol,
                    userAgent: navigator.userAgent.substring(0, 100),
                    inAppBrowser: InAppGuard.isInAppBrowser(),
                    downloadRestricted: InAppGuard.isDownloadRestricted()
                };

                // Try to detect if this is actually a local connection via WebRTC
                try {
                    const rtcInfo = await detectRTCConnectionType();
                    return { ...baseInfo, ...rtcInfo };
                } catch (e) {
                    log("Connection", "Failed to detect RTC connection type:", e);
                    return baseInfo;
                }
            };
        </script>

        <!-- Download UI Manager -->
        <script>
        /**
         * Manages all UI updates for the download process.
         * Encapsulates DOM manipulation, progress tracking, and status display.
         */
        class DownloadUIManager {
            constructor(elements, t, options = {}) {
                // DOM elements
                this.progressBar = elements.progressBar;
                this.statusText = elements.statusText;
                this.connectionType = elements.connectionType;
                this.downloadMessage = elements.downloadMessage;

                // Translation function
                this.t = t;

                // Countdown state
                this.countdownInterval = null;
                this.countdownSeconds = 0;
            }

            setStatus(text, showLoading = false) {
                if (!this.statusText) return;

                this.statusText.innerHTML = '';

                if (showLoading) {
                    const loadingIcon = document.createElement('span');
                    loadingIcon.className = 'loading-icon';
                    loadingIcon.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> ';
                    this.statusText.appendChild(loadingIcon);
                }

                this.statusText.appendChild(document.createTextNode(text));
                document.title = `FastFileLink - ${text}`;
            }

            setConnectionType(text) {
                if (this.connectionType) {
                    this.connectionType.textContent = text;
                }
            }

            setDownloadMessage(text) {
                if (this.downloadMessage) {
                    this.downloadMessage.textContent = text;
                }
            }

            updateProgress(current, total = null) {
                if (this.progressBar) {
                    this.progressBar.value = current;
                }

                if (total) {
                    const percent = Math.round(current * 100 / total);
                    this.setStatus(
                        this.t('client.status.downloadingPercent', 'Downloading via P2P: {{percent}}%', { percent })
                    );
                }
            }

            setProgressMax(max) {
                if (this.progressBar && max > 0) {
                    this.progressBar.max = max;
                }
            }

            removeProgressBar() {
                const progressElements = document.getElementsByClassName('progress');
                Array.from(progressElements).forEach(el => el.remove());
            }

            // ============ Countdown Management ============
            startCountdown(seconds, shouldStopCallback) {
                this.stopCountdown(); // Clear any existing countdown

                this.countdownSeconds = seconds;
                this.setConnectionType(
                    this.t('client.connection.waitingPeer', 'Waiting for peer ({{seconds}}s)', {
                        seconds: this.countdownSeconds
                    })
                );

                this.countdownInterval = setInterval(() => {
                    if (shouldStopCallback && shouldStopCallback()) {
                        this.stopCountdown();
                        return;
                    }

                    this.countdownSeconds--;

                    if (this.countdownSeconds >= 0) {
                        this.setConnectionType(
                            this.t('client.connection.waitingPeer', 'Waiting for peer ({{seconds}}s)', {
                                seconds: this.countdownSeconds
                            })
                        );
                    } else {
                        this.stopCountdown();
                    }
                }, 1000);
            }

            stopCountdown() {
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
            }

            // ============ Connection States ============
            showEstablishingP2P(timeoutSeconds, shouldStopCallback) {
                this.setStatus(
                    this.t('client.status.establishingP2p', 'Establishing P2P connection...'),
                    true
                );
                this.startCountdown(timeoutSeconds, shouldStopCallback);
            }

            showP2PChecking() {
                this.setStatus(
                    this.t('client.status.p2pChecking', 'P2P connection...[Checking]'),
                    true
                );
            }

            showP2PConnecting() {
                this.setStatus(
                    this.t('client.status.p2pConnecting', 'P2P connection...[Connecting]'),
                    true
                );
            }

            showP2PSuccess() {
                this.setStatus(
                    this.t('client.status.p2pSuccess', 'P2P connection successful! Downloading...')
                );
                this.setConnectionType(
                    this.t('client.connection.directP2p', 'Direct P2P transfer')
                );
                this.setDownloadMessage(
                    this.t('client.download.deviceStarted', 'Device-to-Device download started.')
                );
                this.stopCountdown();
            }

            showReconnecting() {
                this.setStatus(
                    this.t('client.status.reconnecting', 'Connection lost, attempting to reconnect...'),
                    true
                );
            }

            showNetworkFluctuation() {
                this.setStatus(
                    this.t('client.status.networkFluctuation', 'Network fluctuation detected, continuing transfer...'),
                    true
                );
            }

            showRetryingP2P() {
                this.setStatus(
                    this.t('client.status.retryingP2p', 'Retrying P2P connectionâ€¦'),
                    true
                );
                this.setConnectionType(
                    this.t('client.connection.retrying', 'Retrying P2P connection')
                );
            }

            showSavingFile() {
                this.setStatus(
                    this.t('client.status.savingFile', 'Saving file...')
                );
            }

            showSwitchingToRelay(reason) {
                this.setStatus(
                    this.t('client.status.switchingRelay', `Switching to relay mode: ${reason}`, { reason })
                );
                this.setConnectionType(
                    this.t('client.connection.serverRelay', 'Using Server Relay Download')
                );
                this.stopCountdown();
            }

            showRelayStarted() {
                this.setStatus(
                    this.t('client.status.relayStarted', 'Relayed P2P Download Started.')
                );
            }

            showBrowserNotSupported() {
                this.setStatus(
                    this.t('client.fallback.browserNotSupported', 'Downloads not supported in this browser')
                );
            }

            showComplete(fileSize) {
                this.setStatus(
                    this.t('download.complete.title', 'âœ… Download complete!')
                );

                if (this.progressBar) {
                    this.progressBar.value = fileSize || 100;
                }

                this.setDownloadMessage(
                    this.t('client.download.fileSaved', 'File saved. Please check your download folder.')
                );

                // Hide progress bar after 1 second
                setTimeout(() => {
                    this.removeProgressBar();
                }, 1000);
            }

            updateFallbackMessage() {
                this.setDownloadMessage(
                    this.t('client.download.startShortly', 'Your download will start shortly.')
                );
            }

            // ============ Cleanup ============
            cleanup() {
                this.stopCountdown();
            }
        }
        </script>

        <!-- Debug Configuration Manager -->
        <script>
        /**
         * Manages debug configuration from URL parameters.
         * Handles test/debug flags for fallback simulation, stall testing, etc.
         */
        class DebugConfigManager {
            constructor(log) {
                // Store log function for use in methods
                this.log = log;

                // Parse all debug parameters from URL
                const urlParams = new URLSearchParams(window.location.search);

                // Fallback timeout override
                const fallbackMsParam = parseInt(urlParams.get('fallback-ms'), 10);
                this.fallbackTimeoutMs = !isNaN(fallbackMsParam) && fallbackMsParam > 0
                    ? fallbackMsParam
                    : null;

                // Force fallback parameters
                this.forceFallback = parseBooleanParam(urlParams.get('force-fallback'));

                const forceFallbackAfterParam = parseInt(urlParams.get('force-fallback-after'), 10);
                this.forceFallbackThreshold = !isNaN(forceFallbackAfterParam) && forceFallbackAfterParam >= 0
                    ? forceFallbackAfterParam
                    : 0;

                // Stall simulation parameters
                this.simulateStall = parseBooleanParam(urlParams.get('simulate-stall'));
                const stallAfterValue = parseInt(urlParams.get('stall-after'));
                this.stallAfterBytes = !isNaN(stallAfterValue) ? stallAfterValue : 50000; // Default 50KB

                // ICE failure simulation
                this.simulateICEFailure = parseBooleanParam(urlParams.get('simulate-ice-failure'));

                // HTTP fallback toggle
                this.httpFallbackEnabled = parseBooleanParam(urlParams.get('fallback'), true); // Default: true

                // Runtime state
                this.forceFallbackIssued = false;

                // Log configuration if any debug mode is active
                if (this.simulateStall || this.simulateICEFailure) {
                    this.log("Debug", `Testing mode enabled: stall=${this.simulateStall} (after ${this.stallAfterBytes} bytes), ice-failure=${this.simulateICEFailure}`);
                }
            }

            getFallbackTimeout(defaultTimeout) {
                return this.fallbackTimeoutMs || defaultTimeout;
            }

            isHTTPFallbackEnabled() {
                return this.httpFallbackEnabled;
            }

            shouldForceFallback(bytesReceived) {
                if (!this.forceFallback || this.forceFallbackIssued) {
                    return false;
                }

                if (bytesReceived > 0 && bytesReceived >= this.forceFallbackThreshold) {
                    this.forceFallbackIssued = true;
                    return true;
                }

                return false;
            }

            shouldLogForceFallbackCandidate() {
                return this.forceFallback && !this.forceFallbackIssued;
            }

            simulateStallIfNeeded(bytesReceived, dataChannel) {
                if (!this.simulateStall || bytesReceived < this.stallAfterBytes) {
                    return false;
                }

                this.log("Debug", `Simulating network stall - closing data channel after ${bytesReceived} bytes`);

                // Simulate real network failure by closing the data channel
                setTimeout(() => {
                    try {
                        dataChannel.close();
                        this.log("Debug", "Data channel closed to simulate network failure");
                    } catch (e) {
                        this.log("Debug", "Error closing data channel:", e);
                    }
                }, 100); // Small delay to complete current processing

                return true; // Indicates stall was simulated
            }

            // Build debug parameters for server offer URL
            buildOfferDebugParams() {
                const debugParams = new URLSearchParams();

                if (this.simulateICEFailure) {
                    debugParams.set('simulate-ice-failure', 'true');
                }
                if (this.simulateStall) {
                    debugParams.set('simulate-stall', 'true');
                    debugParams.set('stall-after', this.stallAfterBytes.toString());
                }

                return debugParams.toString();
            }
        }
        </script>

        <!-- Fallback Manager -->
        <script>
        /**
         * FallbackManager - Handles HTTP fallback logic
         */
        class FallbackManager {
            constructor({
                debugConfig,
                e2eeManager,
                uiManager,
                fileSize,
                log,
                t,
                // Callbacks for external state
                getWritePump,
                getBytesReceived,
                getDownloadCompleted,
                hasTransferStarted,
                isStalled,
                onConnectionFailureHandled
            }) {
                // Configuration dependencies
                this.debugConfig = debugConfig;
                this.e2eeManager = e2eeManager;
                this.uiManager = uiManager;
                this.fileSize = fileSize;
                this.log = log;
                this.t = t;

                // Callbacks
                this.getWritePump = getWritePump;
                this.getBytesReceived = getBytesReceived;
                this.getDownloadCompleted = getDownloadCompleted;
                this.hasTransferStarted = hasTransferStarted;
                this.isStalled = isStalled;
                this.onConnectionFailureHandled = onConnectionFailureHandled;

                this.fallbackTriggered = false;

                // References
                this.downloadManager = null;
                this.fallbackTimer = null;
            }

            // Create fallback timer with timeout
            createFallbackTimer(timeoutMs) {
                this.log("Fallback", `Setting up timeout for ${timeoutMs}ms`);
                this.fallbackTimer = setTimeout(() => {
                    this.log("Fallback", `Timeout reached after ${timeoutMs}ms`);
                    this.triggerFallback("Connection timeout");
                }, timeoutMs);
                return this.fallbackTimer;
            }

            clearFallbackTimer() {
                if (this.fallbackTimer) {
                    clearTimeout(this.fallbackTimer);
                    this.fallbackTimer = null;
                }
            }

            // Main fallback trigger method
            async triggerFallback(reason, force = false) {
                if (!this.debugConfig.isHTTPFallbackEnabled()) {
                    this.log("Fallback", `Skip fallback (${reason}): fallback disabled`);
                    return;
                }

                if (this.fallbackTriggered || this.getDownloadCompleted()) {
                    this.log("Fallback", `Skip fallback (${reason}): already handled`);
                    return;
                }

                // Use callbacks to check external state
                if (!force && this.hasTransferStarted() && !this.isStalled()) {
                    this.log("Fallback", `Skip fallback (${reason}): transfer active / not stalled`);
                    return;
                }

                const writePump = this.getWritePump();
                const bytesReceived = this.getBytesReceived();

                this.log("Fallback", `Switching to HTTP download: ${reason}`);
                this.log("Fallback", `Current state: bytesReceived=${bytesReceived}, pump.bytesWritten=${writePump ? writePump.bytesWritten : 0}`);

                // Prepare WritePump for fallback
                const flushPromise = writePump
                    ? writePump.prepareForFallback(5000, `Fallback: ${reason}`)
                    : Promise.resolve();

                // Notify external state manager that connection failure has been handled
                this.onConnectionFailureHandled();

                // Show UI updates
                this.uiManager.showSwitchingToRelay(reason);
                this.uiManager.updateFallbackMessage();

                try {
                    await this._startDownloadManager(flushPromise, writePump);
                } catch (error) {
                    this.log("Fallback", "DownloadManager failed, redirecting to download URL:", error);
                    window.location.href = '/uid=****/download';
                }

                this.uiManager.showRelayStarted();
            }

            async _startDownloadManager(flushPromise, writePump) {
                const e2eeEnabledValue = (this.e2eeManager && this.e2eeManager.e2eeEnabled);

                // Create DownloadManager instance
                this.downloadManager = new DownloadManager({
                    debug: DEBUG,
                    logFunction: this.log,
                    uid: 'uid=****',
                    e2eeEnabled: e2eeEnabledValue,
                    progressBar: document.getElementById('downloadProgress'),
                    statusHeading: '#download-message',
                    statusDetails: '#status-details',
                    progressInfo: '#connectionType',
                    retryLink: '#retry-link',
                    onServiceWorkerReadyCallback: async (controller) => {
                        if (this.downloadManager.httpDecryptor && controller) {
                            this.log("E2EE", "Sending E2EE context to Service Worker...");
                            this.downloadManager.httpDecryptor.sendContextToServiceWorker('__pre_registered__', controller);
                            this.log("E2EE", "âœ“ E2EE context pre-registered with Service Worker");
                        }
                    },
                    onDownloadStartCallback: (downloadId, total) => {
                        this.log("Fallback", `DownloadManager started, download ID: ${downloadId}, total: ${total}`);

                        if (this.downloadManager.httpDecryptor && navigator.serviceWorker && navigator.serviceWorker.controller) {
                            this.downloadManager.httpDecryptor.sendContextToServiceWorker(downloadId, navigator.serviceWorker.controller);
                            this.log("E2EE", `âœ“ E2EE context sent for specific download ID: ${downloadId}`);
                        }

                        // Notify external state that connection failure is handled
                        this.onConnectionFailureHandled();

                        // Clear P2P timers
                        this.uiManager.stopCountdown();
                        if (this.fallbackTimer) {
                            clearTimeout(this.fallbackTimer);
                        }

                        this.uiManager.setConnectionType(this.t('client.connection.serverRelay', 'Using Server Relay Download'));
                        this.log("Fallback", "Successfully transitioned from P2P to HTTP download");
                    }
                });

                // Setup retry handlers
                this.downloadManager.setupRetryHandlers();

                // Start download
                await flushPromise;
                this.fallbackTriggered = true;

                const actualBytesWritten = writePump ? writePump.bytesWritten : 0;
                const bytesReceived = this.getBytesReceived();
                this.log("Fallback", "Queue flushed, starting DownloadManager download");
                this.log("Fallback", `Current state (after flush): bytesReceived=${bytesReceived}, bytesWritten=${actualBytesWritten}`);

                if (e2eeEnabledValue) {
                    this.downloadManager.httpDecryptor = await this.e2eeManager.setupHTTPDecryptor();
                    this.log("E2EE", "âœ“ HTTP decryptor ready");
                }

                // Calculate resume options
                const resumeOptions = this._calculateResumeOptions(actualBytesWritten);

                this.log("Fallback", `Starting DownloadManager with writer: ${writePump ? 'YES' : 'NO'}, resume: ${resumeOptions ? 'YES' : 'NO'}`);
                this.downloadManager.startDownload({
                    writer: writePump ? writePump.writer : null,
                    resume: resumeOptions
                });
            }

            _calculateResumeOptions(actualBytesWritten) {
                const hasBytes = actualBytesWritten > 0;
                const hasSize = typeof this.fileSize === 'number' && this.fileSize > 0;

                if (!hasBytes || !hasSize) {
                    this.log("Fallback", `Resume not applicable: bytesWritten=${actualBytesWritten}, fileSize=${this.fileSize}`);
                    return null;
                }

                if (actualBytesWritten >= this.fileSize) {
                    this.log("Fallback", `Resume skipped: bytesWritten (${actualBytesWritten}) >= fileSize (${this.fileSize})`);
                    return null;
                }

                const ALIGN = 256 * 1024;
                const alignedStart = Math.floor(actualBytesWritten / ALIGN) * ALIGN;
                const skipBytes = actualBytesWritten - alignedStart;

                const resumePayload = {
                    baseBytes: actualBytesWritten,
                    rangeStart: alignedStart,
                    skipBytes: skipBytes,
                    expectedSize: this.fileSize,
                    chunkSize: ALIGN
                };

                this.log("Fallback", `Resume calculation: baseBytes=${actualBytesWritten}, rangeStart=${alignedStart}, skipBytes=${skipBytes}, expectedSize=${this.fileSize}`);

                if (resumePayload.rangeStart >= 0 && resumePayload.rangeStart < this.fileSize) {
                    this.log("Fallback", `Resume options prepared`);
                    return resumePayload;
                } else {
                    this.log("Fallback", `Resume range invalid: start=${resumePayload.rangeStart}, fileSize=${this.fileSize}`);
                    return null;
                }
            }
        }
        </script>

        <!-- WebRTC and Download Script -->
        <script>

            // Flag to prevent multiple initializations
            let downloadInitialized = false;
            // Timer reference for fallback mechanism
            let startWebRTCTimer = null;

            // Check if WebRTC is supported in the browser
            function isWebRTCSupported() {
                return typeof RTCPeerConnection !== 'undefined' &&
                       typeof RTCDataChannel !== 'undefined';
            }

            // Wait for i18n to be ready before starting
            function startWebRTCDownload() {
            
                // Prevent duplicate execution
                if (downloadInitialized) 
                    return;
                    
                downloadInitialized = true;

                // Cancel fallback timer if it's still pending
                if (startWebRTCTimer) {
                    clearTimeout(startWebRTCTimer);
                    startWebRTCTimer = null;
                }            
                
                (async () => {
                // Initialize Debug Configuration Manager (must be first to configure settings)
                const debugConfig = new DebugConfigManager(log);

                const DISABLE_WEBRTC = false; // Set to true if only use Relayed P2P, this is controlled by Server.
                
                const DEFAULT_FALLBACK_MS = 30000;
                const FALLBACK_MS = debugConfig.getFallbackTimeout(DEFAULT_FALLBACK_MS);
                
                const STALL_MS = 12000; // 12 seconds threshold for detecting stalled transfers
                const CHUNK_SIZE = 256 * 1024;  // 256 KB chunk size for blob storage

                let restartAttempted = false;   // Allow one automatic ICE restart

                let countdownSeconds = Math.floor(FALLBACK_MS / 1000);
                let stopCandidatePolling = false; // trickle ICE polling

                // Connection state tracking
                let disconnectedTime = null;
                let disconnectDuringTransferTimer = null;

                let writePump = null;

                // E2EE Setup
                let e2eeManager = null;
                let webrtcDecryptor = null;
                try {
                    e2eeManager = new E2EEManager(log);
                    const e2eeEnabled = await e2eeManager.checkE2EEStatus();
                    if (e2eeEnabled) {
                        log("E2EE", "ðŸ”’ End-to-End encryption enabled");
                        webrtcDecryptor = await e2eeManager.setupWebRTCDecryptor();
                        log("E2EE", "âœ“ Decryptor ready");
                    }
                } catch (error) {
                    log("E2EE", `Setup failed: ${error.message} - continuing without E2EE`);
                    e2eeManager = null;
                    webrtcDecryptor = null;
                }

                const connectionInfo = await getConnectionInfo();
                log("Client", `Browser: ${connectionInfo.browser}, Domain: ${connectionInfo.domain}`);
                log("Client", `Local: ${connectionInfo.isLocalConnection}, InApp: ${connectionInfo.inAppBrowser}, DownloadRestricted: ${connectionInfo.downloadRestricted}`);

                log("Init", "Starting WebRTC download process");
                log("Config", `Fallback timeout: ${FALLBACK_MS}ms, Chunk size: ${CHUNK_SIZE} bytes`);

                // Initialize DownloadManager for fallback
                let downloadManager = null;

                // Get file metadata
                const fileName = document.getElementById('fileName')?.textContent || 'download.bin';
                const fileSize = parseInt(document.getElementById('fileSize')?.textContent || '0', 10);
                log("File", `Name: ${fileName}, Size: ${fileSize} bytes`);

                // Transfer state tracking
                let dataChannelEstablished = false;
                let bytesReceived = 0;
                let connectionFailureHandled = false;
                let downloadCompleted = false;
                let lastProgressTs = 0; // Progress tracking for stall detection

                // Helper functions for state checking
                const hasTransferStarted = () => {
                    return dataChannelEstablished && bytesReceived > 0;
                };

                const isStalled = () => {
                    if (!hasTransferStarted()) {
                        return false;
                    }

                    if (lastProgressTs === 0) {
                        return false;
                    }

                    const timeSinceLastProgress = Date.now() - lastProgressTs;
                    return timeSinceLastProgress >= STALL_MS;
                };

                // P2P operation control (defined early, will use fallbackManager after it's created)
                let fallbackManager = null;

                const shouldStopPeerOperations = () => {
                    return (fallbackManager && fallbackManager.fallbackTriggered) || connectionFailureHandled || downloadCompleted;
                };

                const shouldHandlePreTransferFailure = () => {
                    return !shouldStopPeerOperations() && !hasTransferStarted();
                };

                // Initialize UI Manager
                const uiManager = new DownloadUIManager({
                    progressBar: document.getElementById('downloadProgress'),
                    statusText: document.getElementById('statusText'),
                    connectionType: document.getElementById('connectionType'),
                    downloadMessage: document.getElementById('download-message')
                }, t);

                // Initialize FallbackManager
                fallbackManager = new FallbackManager({
                    debugConfig,
                    e2eeManager,
                    uiManager,  
                    fileSize,
                    log,
                    t,
                    // Callbacks for external state
                    getWritePump: () => writePump,
                    getBytesReceived: () => bytesReceived,
                    getDownloadCompleted: () => downloadCompleted,
                    hasTransferStarted,
                    isStalled,
                    onConnectionFailureHandled: () => { connectionFailureHandled = true; }
                });

                // Convenience method for triggering fallback
                const fallbackToHTTP = (reason, force = false) => fallbackManager.triggerFallback(reason, force);

                // Set progress bar max if we know the file size
                uiManager.setProgressMax(fileSize);

                // Initialize writer and WritePump early (always available for both P2P and HTTP fallback)
                // Check if file download is supported
                if (!WriterFactory.isSupported(fileSize)) {
                    const reason = WriterFactory.getUnsupportedReason(fileSize);
                    log("WriterFactory", `File download not supported: ${reason}`);
                    // Skip WebRTC and go directly to HTTP fallback
                    fallbackToHTTP(t('client.fallback.fileTooBig', 'File too large for direct download - using server relay'));
                    return;
                }

                // Create writer using WriterFactory (StreamSaver or Blob based on file size)
                const writerContext = WriterFactory.create(fileName, fileSize);
                log("WriterFactory", `Created ${writerContext.type} writer`);

                // Initialize WritePump - always available for entire download flow
                writePump = new WritePump(writerContext.writer, fileSize, {
                    onComplete: ({ bytesWritten, writer }) => {
                        log("Download", `âœ… Complete! ${bytesWritten} bytes written`);
                        downloadComplete();
                    },
                    onFallback: (reason) => {
                        log("Download", `WritePump fallback: ${reason}`);
                        if (!shouldStopPeerOperations()) {
                            fallbackToHTTP(reason, true);
                        }
                    },
                    log: log
                });

                log("WritePump", `Initialized for ${writerContext.type} download (always available)`);

                // Handle download completion
                // Will be enhanced with cleanup callback after WebRTC setup
                let cleanupConnectionsCallback = null;

                function downloadComplete() {
                    if (downloadCompleted) {
                        return;
                    }

                    if (fileSize && bytesReceived < fileSize) {
                        log("Download", `Incomplete P2P transfer detected: expected ${fileSize}, got ${bytesReceived}`);
                        if (!shouldStopPeerOperations()) {
                            fallbackToHTTP("Incomplete P2P transfer detected", true);
                        }
                        return;
                    }

                    log("Download", "Complete!");

                    downloadCompleted = true;

                    // Show completion UI
                    uiManager.showComplete(fileSize);

                    // Notify server that download is complete
                    if (typeof peerId !== 'undefined' && peerId) {
                        log("Signal", `Notifying server of download completion for peer ${peerId}`);
                        fetch('/uid=****/complete', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ peerId: peerId, receivedBytes: bytesReceived }),
                        }).then(() => {
                            log("Signal", "Successfully notified server of completion");
                        }).catch(err => {
                            log("Signal", `Failed to notify server of completion: ${err}`);
                            // Don't fail the download if notification fails
                        });
                    }

                    // P2P download completed successfully
                    stopCandidatePolling = true;
                    connectionFailureHandled = true;

                    fallbackManager.clearFallbackTimer();

                    // Cleanup countdown timer
                    uiManager.stopCountdown();

                    // Cleanup WebRTC connections if callback is set (P2P mode)
                    if (cleanupConnectionsCallback) {
                        cleanupConnectionsCallback();
                    }
                }

                // Check if we should skip WebRTC due to browser support or download restrictions
                const webrtcSupported = isWebRTCSupported();

                if (!webrtcSupported || DISABLE_WEBRTC || SKIP_WEBRTC_DUE_TO_RESTRICTION) {
                    if (!webrtcSupported) {
                        log("WebRTC", "WebRTC not supported in this browser (RTCPeerConnection or RTCDataChannel unavailable)");
                        fallbackToHTTP(t('client.fallback.webrtcNotSupported', 'WebRTC not supported - using server relay'));
                    } else if (SKIP_WEBRTC_DUE_TO_RESTRICTION) {
                        uiManager.showBrowserNotSupported();
                    } else {
                        fallbackToHTTP(t('client.fallback.p2pDisabled', 'Device-to-Device P2P disabled. Use Relayed P2P.'));
                    }
                    return;
                }
                
                // Initialize status & countdown
                uiManager.showEstablishingP2P(countdownSeconds, shouldStopPeerOperations);

                // Request offer from server
                log("WebRTC", "Requesting offer from server");
                let offerResponse;
                try {
                    // Build offer URL with debug parameters
                    let offerUrl = '/uid=****/offer';
                    const debugParams = debugConfig.buildOfferDebugParams();

                    if (debugParams) {
                        offerUrl += '?' + debugParams;
                        log("WebRTC", `Using debug offer URL: ${offerUrl}`);
                    }

                    offerResponse = await fetch(offerUrl);
                    log("WebRTC", `Got response: ${offerResponse.status} ${offerResponse.statusText}`);
                } catch (err) {
                    log("WebRTC", "Failed to fetch offer:", err);
                    fallbackToHTTP("Failed to get offer from server");
                    return;
                }
                    
                if (!offerResponse.ok) {
                    log("WebRTC", `Server returned ${offerResponse.status}: ${offerResponse.statusText}`);
                    fallbackToHTTP(`Server returned ${offerResponse.status}`);
                    return;
                }
                    
                // Parse offer data
                let offerData;
                let peerId; // Store the peer ID for all future communications
                try {
                    offerData = await offerResponse.json();
                    log("WebRTC", `Parsed offer data: type=${offerData.type}, sdp length=${offerData.sdp.length}`);
                    log("WebRTC", `SDP excerpt: ${offerData.sdp.substring(0, 50)}...`);
                        
                    // Store the peerId for future use
                    peerId = offerData.peerId;
                    log("WebRTC", `Got peerId: ${peerId}`);
                } catch (err) {
                    log("WebRTC", "Failed to parse offer data:", err);
                    fallbackToHTTP("Invalid offer data from server");
                    return;
                }              
              
                try {
                    // ============================================================
                    // WebRTC P2P Connection Setup
                    // ============================================================
                    // This section:
                    // 1. Creates RTCPeerConnection with STUN servers
                    // 2. Sets up fallback timeout for connection failures
                    // 3. Registers event handlers for ICE state changes
                    // 4. Handles ICE candidate exchange (trickle ICE)
                    // 5. Manages data channel for file transfer
                    // ============================================================

                    log("WebRTC", "Creating peer connection");
                    const pc = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun.cloudflare.com:3478' },
                            { urls: 'stun:stun.nextcloud.com:443' },
                            { urls: 'stun:openrelayproject.org:80' },
                            { urls: 'stun:openrelayproject.org:443' }
                        ],
                    });
                    log("WebRTC", "Peer connection created:", pc);

                    // Fallback timer
                    fallbackManager.createFallbackTimer(FALLBACK_MS);

                    // ============ ICE Connection State Handler ============
                    // lifecycle: checking â†’ connected â†’ completed/failed/disconnected.
                    const handleICEConnectionStateChange = () => {
                        log("ICE", `Connection state changed to: ${pc.iceConnectionState}`);

                        // If P2P operations should stop, ignore
                        if (shouldStopPeerOperations()) {
                            return;
                        }

                        switch (pc.iceConnectionState) {
                            case 'checking':
                                uiManager.showP2PChecking();
                                break;

                            case 'connected':
                                // Clear countdown and disconnect timers when connection established
                                uiManager.stopCountdown();
                                log("UI", "Countdown cleared on connection established");
                                disconnectedTime = null;

                                if (disconnectDuringTransferTimer) {
                                    clearTimeout(disconnectDuringTransferTimer);
                                    disconnectDuringTransferTimer = null;
                                }

                                stopCandidatePolling = true;
                                log("ICE", "Connection established successfully");
                                break;

                            case 'completed':
                                disconnectedTime = null;

                                if (disconnectDuringTransferTimer) {
                                    clearTimeout(disconnectDuringTransferTimer);
                                    disconnectDuringTransferTimer = null;
                                }

                                log("ICE", "All ICE candidates have been found");
                                break;

                            case 'disconnected':
                                log("ICE", "Connection lost temporarily");

                                if (!hasTransferStarted()) {
                                    disconnectedTime = Date.now();
                                    uiManager.showReconnecting();

                                    // Increased timeout for pre-transfer disconnections
                                    setTimeout(() => {
                                        if (pc.iceConnectionState === 'disconnected' &&
                                            disconnectedTime &&
                                            Date.now() - disconnectedTime > 15000 &&
                                            shouldHandlePreTransferFailure()) {

                                            fallbackToHTTP("Connection lost before transfer started");
                                        }
                                    }, 16000);

                                // During transfer: show network fluctuation and set fallback timer
                                } else {
                                    log("ICE", "Network fluctuation during transfer - continuing");
                                    uiManager.showNetworkFluctuation();

                                    // Don't create duplicate timers
                                    if (!disconnectDuringTransferTimer) {
                                        const delay = STALL_MS + 3000; // Buffer beyond stall detection

                                        disconnectDuringTransferTimer = setTimeout(() => {
                                            disconnectDuringTransferTimer = null;

                                            // Exit if download already completed or fallback triggered
                                            if (shouldStopPeerOperations()) {
                                                return;
                                            }

                                            // Exit if ICE recovered to connected/completed
                                            if (pc.iceConnectionState !== 'disconnected') {
                                                return;
                                            }

                                            // Conservative: only fallback if transfer started AND actually stalled
                                            if (!hasTransferStarted() || !isStalled()) {
                                                return;
                                            }

                                            log("ICE", "Still disconnected and stalled - switching to HTTP fallback");
                                            // Use force = true to bypass "transfer in progress" protection
                                            fallbackToHTTP("ICE disconnected during active transfer (stalled)", true);
                                        }, delay);
                                    }
                                }
                                break;

                            case 'failed':
                                // Only handle failure if transfer hasn't started
                                if (!hasTransferStarted()) {
                                    if (!restartAttempted) {
                                        restartAttempted = true;
                                        log("ICE", "ICE failed â€“ trying restartIce() once");
                                        pc.restartIce();
                                        uiManager.showRetryingP2P();

                                        setTimeout(() => {
                                            if ((pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') &&
                                                shouldHandlePreTransferFailure()) {

                                                fallbackToHTTP("Connection restart failed");
                                            }
                                        }, 20000);
                                    } else {
                                        fallbackToHTTP("Connection failed after restart");
                                    }
                                } else {
                                    log("ICE", "ICE failed during transfer - but data channel still active");
                                }
                                break;

                            case 'closed':
                                log("ICE", "Connection closed");
                                break;
                        }
                    };

                    // ICE connection state monitoring with improved logic
                    pc.oniceconnectionstatechange = handleICEConnectionStateChange;
                    
                    // Simplified connection state monitoring to avoid conflicts
                    pc.onconnectionstatechange = () => {
                        if (shouldStopPeerOperations()) {
                            return;
                        }
                        
                        // Only handle clear failures before transfer starts
                        if (pc.connectionState === 'failed' &&
                            shouldHandlePreTransferFailure()) {
                            
                            fallbackToHTTP("WebRTC connection failed");
                        }
                    };

                    // ============ ICE Candidate Handlers ============
                    const sendLocalCandidate = (candidate) => {
                        const candidateData = {
                            peerId: peerId,
                            candidate: candidate.candidate,
                            sdpMid: candidate.sdpMid,
                            sdpMLineIndex: candidate.sdpMLineIndex
                        };

                        const candidateJson = JSON.stringify(candidateData);
                        log("ICE", `New candidate: ${candidate.candidate?.substring(0, 50)}...`);

                        log("ICE", `Sending candidate to server: ${candidateJson.substring(0, 50)}...`);
                        fetch('/uid=****/candidate', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: candidateJson,
                        }).then(() => {
                            log("ICE", `Successfully sent candidate to server`);
                            if (!shouldStopPeerOperations()) {
                                uiManager.showP2PConnecting();
                            }
                        }).catch(err => {
                            log("ICE", `Failed to send candidate:`, err);
                            // Continue despite error - this might not be fatal
                        });
                    };

                    const sendEndOfCandidates = () => {
                        const endCandidatesData = {
                            peerId: peerId,
                            candidate: 'end-of-candidates'
                        };

                        fetch('/uid=****/candidate', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(endCandidatesData),
                        }).catch(err => {
                            log("ICE", `Failed to send end-of-candidates:`, err);
                        });

                        log("ICE", "All candidates gathered");
                    };

                    const handleICECandidate = (event) => {
                        if (event.candidate) {
                            sendLocalCandidate(event.candidate);
                        } else {
                            sendEndOfCandidates();
                        }
                    };

                    // Process and send ICE candidates
                    pc.onicecandidate = handleICECandidate;

                    // ============ Data Channel Setup ============
                    const setupDataChannelHandlers = (dc) => {
                        // Configure data channel
                        dc.binaryType = 'arraybuffer';
                        log("DataChannel", `Binary type set to: ${dc.binaryType}`);

                        // Register cleanup callback for downloadComplete function
                        cleanupConnectionsCallback = () => {
                            setTimeout(() => {
                                log("WebRTC", "Closing peer connection");

                                try {
                                    dc.close();
                                    log("DataChannel", "Closed");
                                } catch (e) {
                                    log("DataChannel", "Error closing:", e);
                                }

                                try {
                                    pc.close();
                                    log("WebRTC", "Peer connection closed");
                                } catch (e) {
                                    log("WebRTC", "Error closing peer connection:", e);
                                }
                            }, 500);
                        };

                        // Enhanced data channel state monitoring
                        dc.onopen = () => {
                            log("DataChannel", "Channel opened");
                            dataChannelEstablished = true;
                            lastProgressTs = Date.now();
                        };

                        dc.onclose = () => {
                            log("DataChannel", "Channel closed");
                            const bytesWrittenSoFar = writePump.bytesWritten;
                            if (!shouldStopPeerOperations() && bytesWrittenSoFar < fileSize) {
                                log("DataChannel", `Channel closed before completion (written: ${bytesWrittenSoFar}/${fileSize})`);
                                fallbackToHTTP("Data channel closed unexpectedly", true);
                            }
                        };

                        dc.onerror = (err) => {
                            log("DataChannel", "Error:", err);
                            if (!shouldStopPeerOperations()) {
                                fallbackToHTTP("Data channel error", true);
                            }
                        };
                    };

                    // Main handler called when a data channel is received from the peer.
                    const handleDataChannelReceived = (dc) => {
                        log("DataChannel", `Received data channel: ${dc.label}, ID: ${dc.id}`);
                        log("DataChannel", `ordered=${dc.ordered}, maxRetransmits=${dc.maxRetransmits ?? 'null'}, maxPacketLifeTime=${dc.maxPacketLifeTime ?? 'null'}`);

                        dataChannelEstablished = true;
                        lastProgressTs = Date.now(); // Initialize progress timestamp when channel is established

                        // Update UI for successful connection
                        // Update UI for successful P2P connection
                        uiManager.showP2PSuccess();
                        fallbackManager.clearFallbackTimer();
                        log("Fallback", "Cleared timeout - connection successful");

                        // Setup all data channel handlers
                        setupDataChannelHandlers(dc);

                        // ============ Data Channel Message Handlers ============
                        let received = 0;
                        let chunks = 0;
                        let lastProgressUpdate = 0;
                        const PROGRESS_THROTTLE_MS = 50; // Faster progress updates (50ms)

                        // Sequential processing to prevent race conditions (especially for small files)
                        let messageProcessingChain = Promise.resolve();

                        // Handles control messages received over the data channel (EOF, ERROR, etc.).
                        const handleControlMessage = async (message) => {
                            log("DataChannel", `Received string message: ${message}`);

                            if (message === 'EOF') {
                                log("DataChannel", `End of file received after ${chunks} chunks, ${received} bytes`);
                                uiManager.showSavingFile();

                                // EOF with deadline - if writer stuck, fallback to HTTP resume
                                const FINISH_DEADLINE_MS = 10000; // 10 seconds for writer to finish
                                try {
                                    await Promise.race([
                                        writePump.eof(),
                                        new Promise((_, reject) =>
                                            setTimeout(() => reject(new Error('writer-finish-timeout')), FINISH_DEADLINE_MS)
                                        )
                                    ]);
                                    // Success - EOF completed within deadline
                                } catch (err) {
                                    // Writer stuck (SW/mitm not accepting writes fast enough)
                                    log("DataChannel", `Writer finish timeout after ${FINISH_DEADLINE_MS}ms: ${err.message}`);
                                    log("DataChannel", `Preparing for HTTP fallback with resume from ${writePump.bytesWritten} bytes`);

                                    // Prepare for fallback - flush pending writes but keep writer open
                                    await writePump.prepareForFallback(5000, 'Writer stuck finishing after EOF');

                                    // Trigger HTTP fallback with resume support
                                    fallbackToHTTP('Writer stuck finishing after EOF', true);
                                }
                            } else if (message === 'ERROR') {
                                log("DataChannel", "Server reported error");
                                if (!shouldStopPeerOperations()) {
                                    fallbackToHTTP("Server reported error", true);
                                }
                            } else {
                                log("DataChannel", `Unknown string message: ${message}`);
                            }
                        };

                        const updateProgressUI = (received, chunks) => {
                            const now = Date.now();
                            if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS || received === fileSize) {
                                lastProgressUpdate = now;

                                // Log progress periodically
                                if (chunks % 50 === 0 || received === fileSize) {
                                    log("Progress", `Received ${chunks} chunks, ${received} bytes (written: ${writePump.bytesWritten})`);
                                }

                                // Update UI progress
                                uiManager.updateProgress(received, fileSize);
                            }
                        };

                        const handleBinaryData = async (data) => {
                            log("DataChannel", `Received binary message: chunks: ${chunks}`);
                            
                            // Binary data - decrypt if E2EE enabled
                            let plainData = data;
                            if (webrtcDecryptor) {
                                const encryptedChunk = new Uint8Array(data);
                                plainData = (await webrtcDecryptor.decryptChunk(encryptedChunk)).buffer;
                            }

                            // Update progress immediately (not tied to writing)
                            chunks++;
                            received += plainData.byteLength;
                            bytesReceived = received; // Update global tracker for UI/progress

                            if (debugConfig.shouldLogForceFallbackCandidate()) {
                                log(
                                    "Fallback",
                                    `Force fallback candidate: chunk=${plainData.byteLength}, received=${bytesReceived}, threshold=${debugConfig.forceFallbackThreshold}`
                                );
                            }

                            if (debugConfig.shouldForceFallback(bytesReceived)) {
                                log("Fallback", "Force fallback parameter detected - switching to HTTP");
                                fallbackToHTTP("Forced fallback via URL parameter", true);
                                return;
                            }

                            // Debug: Simulate stall after specified bytes
                            if (debugConfig.simulateStallIfNeeded(received, dc)) {
                                return;
                            }

                            lastProgressTs = Date.now(); // Update progress timestamp

                            // Queue data for writing - WritePump handles all write ordering
                            writePump.enqueue(new Uint8Array(plainData));

                            // Immediate progress updates (not tied to write completion)
                            updateProgressUI(received, chunks);
                        };

                        const handleDataChannelMessage = async (data) => {
                            // Check message type (control or data)
                            if (typeof data === 'string') {
                                await handleControlMessage(data);
                            } else {
                                await handleBinaryData(data);
                            }
                        };

                        dc.onmessage = ({ data }) => {
                            // Chain message processing to ensure sequential execution
                            messageProcessingChain = messageProcessingChain
                                .then(() => handleDataChannelMessage(data))
                                .catch(err => {
                                    log("DataChannel", `Message processing error: ${err}`);
                                    if (!shouldStopPeerOperations()) {
                                        fallbackToHTTP("Message processing error", true);
                                    }
                                });
                        };
                    };

                    // Handle data channel with improved state tracking
                    log("WebRTC", "Setting up data channel handler");
                    pc.ondatachannel = ({ channel: dc }) => {
                        handleDataChannelReceived(dc);
                    };

                    // ============ SDP Exchange (Offer/Answer) ============
                    const setRemoteOffer = async () => {
                        log("WebRTC", "Setting remote description");
                        try {
                            await pc.setRemoteDescription({ type: offerData.type, sdp: offerData.sdp });
                            log("WebRTC", "Remote description set successfully");
                        } catch (err) {
                            log("WebRTC", "Failed to set remote description:", err);
                            fallbackToHTTP("Failed to set remote description");
                            throw err; // Re-throw to stop execution
                        }
                    };

                    const createAndSetAnswer = async () => {
                        log("WebRTC", "Creating answer");
                        try {
                            const answer = await pc.createAnswer();
                            log("WebRTC", `Answer created: type=${answer.type}, sdp length=${answer.sdp.length}`);
                            log("WebRTC", `Answer SDP excerpt: ${answer.sdp.substring(0, 50)}...`);

                            log("WebRTC", "Setting local description");
                            await pc.setLocalDescription(answer);
                            log("WebRTC", "Local description set successfully");

                            return answer;
                        } catch (err) {
                            log("WebRTC", "Failed to create/set answer:", err);
                            fallbackToHTTP("Failed to create answer");
                            throw err; // Re-throw to stop execution
                        }
                    };

                    const sendAnswerToServer = async () => {
                        log("WebRTC", "Sending answer to server");
                        try {
                            const answerResponse = await fetch('/uid=****/answer', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    peerId: peerId,
                                    sdp: pc.localDescription.sdp,
                                    type: pc.localDescription.type,
                                    clientInfo: connectionInfo
                                }),
                            });
                            log("WebRTC", `Answer sent, response: ${answerResponse.status} ${answerResponse.statusText}`);
                        } catch (err) {
                            log("WebRTC", "Failed to send answer:", err);
                            fallbackToHTTP("Failed to send answer to server");
                            throw err; // Re-throw to stop execution
                        }
                    };

                    // ============ Remote ICE Candidate Polling ============
                    // Polls the server for remote ICE candidates and adds them to the peer connection.
                    // Continues until end-of-candidates is received or an error occurs.
                    const startPollingRemoteCandidates = async (pcRef) => {
                        while (!stopCandidatePolling) {
                            try {
                                // GET /uid=****/candidate  (204 = Temporarily unavailable)
                                const resp = await fetch(`/uid=****/candidate?peer=${peerId}`);
                                if (resp.status === 204) {
                                    await new Promise(r => setTimeout(r, 200)); // Ask again in 200 ms
                                    continue;
                                }
                                if (resp.status === 404) {
                                    log("ICE", "Server reports peer closed, stop polling");
                                    break;
                                }
                                if (!resp.ok) {                               // Exit on other errors
                                    log("ICE", `Fetch remote cand failed: ${resp.status}`);
                                    break;
                                }

                                const cand = await resp.json();
                                if (cand.candidate === "end-of-candidates") { // All candidates received
                                    log("ICE", "End-of-candidates from server");
                                    break;
                                }

                                log("ICE", `Remote candidate: ${cand.candidate?.substring(0,50)}...`);
                                await pcRef.addIceCandidate(cand);            // Add to ICE agent
                            } catch (err) {
                                log("ICE", `Polling error: ${err}`);
                                break;
                            }
                        }
                    };

                    // ============ Execute SDP Exchange ============
                    // Set remote description (server's offer)
                    await setRemoteOffer();

                    // Create answer and set as local description
                    await createAndSetAnswer();

                    // Send answer to server and start candidate polling
                    await sendAnswerToServer();
                    startPollingRemoteCandidates(pc);

                    log("WebRTC", "Waiting for data channel...");
                } catch (err) {
                    log("WebRTC", "General error:", err);
                    fallbackToHTTP(`Error: ${err.message}`);
                }
                })(); // End of async function
            } // End of startWebRTCDownload function
            
            // Listen for i18n ready event
            window.addEventListener('i18nReady', startWebRTCDownload);

            // Fallback: if i18nReady doesn't fire within 2 seconds, proceed anyway
            startWebRTCTimer = setTimeout(() => {
                startWebRTCDownload();
            }, 2000);
        </script>
        
        <script>
            // Status polling for server-side error notifications
            let statusPoller = null;
            let consecutiveStatusFailures = 0;
            const MAX_STATUS_FAILURES = 2;

            function startStatusPolling() {
                // Poll every 2 seconds
                statusPoller = setInterval(async () => {
                    try {
                        const response = await fetch('/status');
                        if (!response.ok) {
                            consecutiveStatusFailures++;
                            log("Status", `Status request failed (${response.status}): ${consecutiveStatusFailures}/${MAX_STATUS_FAILURES}`);

                            // Stop polling after consecutive failures
                            if (consecutiveStatusFailures >= MAX_STATUS_FAILURES) {
                                log("Status", `Stopping status polling after ${MAX_STATUS_FAILURES} consecutive failures`);
                                stopStatusPolling();
                            }
                            return;
                        }

                        // Reset failure counter on success
                        consecutiveStatusFailures = 0;

                        const status = await response.json();
                        if (status.error) {
                            // Get message based on error type (i18n support)
                            const message = getErrorMessage(status.error);

                            // Show error notification
                            showErrorNotification(message);

                            // Stop polling after error is received
                            stopStatusPolling();

                            // Log error details for debugging
                            if (status.error.detail) {
                                log("Status", `Error detail: ${status.error.detail}`);
                            }
                        }
                    } catch (e) {
                        // Count network errors as failures
                        consecutiveStatusFailures++;
                        console.debug(`Status polling error (${consecutiveStatusFailures}/${MAX_STATUS_FAILURES}):`, e);

                        // Stop polling after consecutive network errors
                        if (consecutiveStatusFailures >= MAX_STATUS_FAILURES) {
                            log("Status", `Stopping status polling after ${MAX_STATUS_FAILURES} consecutive network errors`);
                            stopStatusPolling();
                        }
                    }
                }, 2000);
            }

            function stopStatusPolling() {
                if (statusPoller) {
                    clearInterval(statusPoller);
                    statusPoller = null;
                }
            }

            function getErrorMessage(error) {
                // Map error types to i18n keys with default fallback messages
                const errorDefaults = {
                    'folder_changed': 'The shared folder contents changed during transfer. The file owner needs to reshare the folder.',
                    // Add more error types here as needed
                };

                // Use i18next for known error types
                if (error.type && errorDefaults[error.type]) {
                    // Use window.t() which safely handles i18next initialization
                    return window.t(`errors.${error.type}`, errorDefaults[error.type]);
                } else {
                    // Unknown error type - use server's detail message or generic fallback
                    return error.detail || window.t('errors.unknown', 'An error occurred during transfer.');
                }
            }

            function showErrorNotification(message) {
                // Create notification element if it doesn't exist
                let notification = document.getElementById('error-notification');
                if (!notification) {
                    notification = document.createElement('div');
                    notification.id = 'error-notification';
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        background-color: #dc3545;
                        color: white;
                        padding: 15px 25px;
                        border-radius: 5px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                        z-index: 10000;
                        max-width: 600px;
                        text-align: center;
                        font-size: 16px;
                        font-weight: 500;
                    `;
                    document.body.appendChild(notification);
                }

                // Set message
                notification.textContent = `âš ï¸ ${message}`;
                notification.style.display = 'block';

                // Also log to console
                log("Error", message);
            }

            // Start status polling when page loads
            startStatusPolling();

            // Stop polling when page is closed
            window.addEventListener('beforeunload', stopStatusPolling);

        </script>
    </body>
</html>
